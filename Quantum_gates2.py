import numpy as np  # Импорт библиотеки NumPy для работы с векторами и линейной алгеброй
import matplotlib.pyplot as plt  # Импорт модуля pyplot из matplotlib для визуализации графиков

# ========= 1. Визуализация одиночного кубита =========
def visualize_qubit(qubit, title="Состояние кубита"):
    """
    Отображение вероятностей состояния кубита в виде столбчатой диаграммы
    """
    probabilities = np.abs(qubit.state) ** 2  # Вычисление вероятностей как квадратов модулей амплитуд
    labels = ['|0⟩', '|1⟩']  # Задание меток для столбцов диаграммы

    plt.bar(labels, probabilities, color=['#4A90E2', '#50E3C2'])  # Построение столбчатой диаграммы
    plt.ylim(0, 1)  # Установка границ оси Y от 0 до 1
    plt.title(title)  # Назначение заголовка графика
    plt.ylabel('Вероятность')  # Подпись оси Y

    for i, v in enumerate(probabilities):  # Цикл по индексам и значениям вероятностей
        plt.text(i, v + 0.02, f"{v:.2f}", ha='center')  # Отображение числовых значений над столбцами

    plt.show()  # Отображение финального графика


# ========= 2. Визуализация пары кубитов =========
def visualize_pair(state_vector, title="Состояние пары кубитов"):
    """
    Отображение вероятностей четырёх состояний двух кубитов в виде диаграммы
    """
    probabilities = np.abs(state_vector) ** 2  # Вычисление вероятностей из амплитуд
    labels = ['|00⟩', '|01⟩', '|10⟩', '|11⟩']  # Определение меток для четырёх базисных состояний

    plt.bar(labels, probabilities, color=['#4A90E2', '#50E3C2', 'orange', '#AD66D5'])  # Построение диаграммы
    plt.ylim(0, 1)  # Установка границ оси Y
    plt.title(title)  # Заголовок диаграммы
    plt.ylabel('Вероятность')  # Подпись оси Y

    for i, v in enumerate(probabilities):  # Цикл по значениям вероятностей
        plt.text(i, v + 0.02, f"{v:.2f}", ha='center')  # Отображение числовых значений над столбцами

    plt.show()  # Отображение графика


# ========= 3. Класс Qubit =========
class Qubit:
    def __init__(self, alpha=1.0, beta=0.0):
        """
        Инициализация кубита с амплитудами α и β; по умолчанию — состояние |0⟩
        """
        self.state = np.array([complex(alpha), complex(beta)], dtype=complex)  # Создание вектора состояния
        self.normalize()  # Нормализация вектора

    def normalize(self):
        """
        Нормализация вектора состояния: сумма квадратов модулей должна равняться 1
        """
        norm = np.linalg.norm(self.state)  # Вычисление евклидовой нормы вектора
        if norm == 0:  # Проверка на нулевой вектор
            raise ValueError("Нулевой вектор состояния недопустим.")  # Генерация исключения при ошибке
        self.state /= norm  # Деление каждого элемента вектора на норму

    def apply_gate(self, gate_matrix):
        """
        Применение квантового гейта (матрицы 2×2) к текущему состоянию
        """
        self.state = np.dot(gate_matrix, self.state)  # Умножение матрицы гейта на вектор состояния

    def measure(self):
        """
        Симуляция измерения кубита с вероятностями |α|² и |β|²
        """
        probabilities = np.abs(self.state) ** 2  # Вычисление вероятностей
        return np.random.choice([0, 1], p=probabilities)  # Выбор результата 0 или 1 согласно вероятностям

    def __str__(self):
        """
        Форматирование состояния кубита в строку вида α|0⟩ + β|1⟩
        """
        return f"{self.state[0]:.2f}|0⟩ + {self.state[1]:.2f}|1⟩"  # Возврат строкового представления


# ========= 4. Гейты Паули =========
def pauli_x():
    return np.array([[0, 1], [1, 0]], dtype=complex)  # Матрица X — обмен |0⟩ и |1⟩

def pauli_y():
    return np.array([[0, -1j], [1j, 0]], dtype=complex)  # Матрица Y — обмен с фазовым множителем

def pauli_z():
    return np.array([[1, 0], [0, -1]], dtype=complex)  # Матрица Z — смена знака у |1⟩


# ========= 5. Гейт Адамара =========
def hadamard():
    """
    Гейт Адамара — преобразование |0⟩ и |1⟩ в суперпозиционные состояния
    """
    return (1 / np.sqrt(2)) * np.array([[1, 1], [1, -1]], dtype=complex)  # Нормализованная матрица H


# ========= 6. Гейт CNOT =========
def cnot():
    """
    Матрица CNOT — управляемый X-гейт, инвертирующий второй кубит, если первый равен 1
    """
    return np.array([
        [1, 0, 0, 0],  # |00⟩ → |00⟩
        [0, 1, 0, 0],  # |01⟩ → |01⟩
        [0, 0, 0, 1],  # |10⟩ → |11⟩
        [0, 0, 1, 0]   # |11⟩ → |10⟩
    ], dtype=complex)


# ========= 7. Класс QubitPair =========
class QubitPair:
    def __init__(self, q1: Qubit, q2: Qubit):
        """
        Создание пары кубитов как тензорного произведения состояний двух кубитов
        """
        self.state = np.kron(q1.state, q2.state)  # Вычисление тензорного произведения векторов состояний

    def apply_gate(self, gate_matrix):
        """
        Применение двухкубитного гейта (матрицы 4×4) к паре кубитов
        """
        self.state = np.dot(gate_matrix, self.state)  # Умножение гейта на тензорное состояние

    def __str__(self):
        """
        Строковое представление в виде суммы коэффициентов у |00⟩, |01⟩, |10⟩, |11⟩
        """
        return (f"{self.state[0]:.2f}|00⟩ + {self.state[1]:.2f}|01⟩ + "
                f"{self.state[2]:.2f}|10⟩ + {self.state[3]:.2f}|11⟩")  # Форматированный вывод


# ========= Демонстрация =========

q = Qubit(1, 0)  # Инициализация кубита в состоянии |0⟩
print("Начальное состояние:", q)  # Вывод начального состояния
visualize_qubit(q, "Начальное состояние |0⟩")  # Визуализация состояния

q.apply_gate(pauli_x())  # Применение гейта X
print("После X-гейта:", q)  # Вывод состояния
visualize_qubit(q, "После X-гейта")  # Визуализация результата

q.apply_gate(pauli_y())  # Применение гейта Y
print("После Y-гейта:", q)  # Вывод состояния
visualize_qubit(q, "После Y-гейта")  # Визуализация результата

q.apply_gate(pauli_z())  # Применение гейта Z
print("После Z-гейта:", q)  # Вывод состояния
visualize_qubit(q, "После Z-гейта")  # Визуализация результата


# Суперпозиция через H-гейт
q_super = Qubit(1, 0)  # Кубит в состоянии |0⟩
q_super.apply_gate(hadamard())  # Применение гейта Адамара
print("Суперпозиция после H:", q_super)  # Вывод состояния
visualize_qubit(q_super, "Кубит после H (суперпозиция)")  # Визуализация суперпозиции


# Запутывание пары кубитов
q1 = Qubit(1, 0)  # Первый кубит в состоянии |0⟩
q2 = Qubit(1, 0)  # Второй кубит в состоянии |0⟩

q1.apply_gate(hadamard())  # Применение H-гейта к первому кубиту

pair = QubitPair(q1, q2)  # Создание пары кубитов
pair.apply_gate(cnot())  # Применение CNOT-гейта
print("Запутанное состояние (Bell):", pair)  # Вывод запутанного состояния
visualize_pair(pair.state, "Запутанное состояние Bell: (|00⟩ + |11⟩)/√2")  # Визуализация
